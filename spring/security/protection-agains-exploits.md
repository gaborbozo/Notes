## Cross Site Request Forgery (CSRF)
Happens when the user while authenticated on the target (JSESSIONID already defined & valid) website, is manipulated into sending a maliciously crafted request (e.g., via a link or form).
CSRF attack is possible because the HTTP request from the victim’s website and the request from the attacker’s website are exactly the same. To protect against it, we need to ensure there is something in the request that the evil site is unable to provide.

For either protection against CSRF to work, the application must ensure that "safe" HTTP methods are read-only which means that requests with the HTTP `GET`, `HEAD`, `OPTIONS`, and `TRACE` methods should not change the state of the application.
> For instance, if a `GET` request unintentionally updates user preferences or deletes a resource, it changes the application's state.
### Synchronizer Token Pattern
This solution is to ensure that each HTTP request requires, in addition to our session cookie, a secure random generated value called a CSRF token be present in the HTTP request. When HTTP request is submitted, the server must look up the expected CSRF token and compare it against the actual CSRF token in the HTTP request. If the values do not match, the HTTP request should be rejected.

The key to this working is that the actual CSRF token should be in a part of the HTTP request that is not automatically included by the browser. F.e. requiring the actual CSRF token in an HTTP parameter or an HTTP header will protect against CSRF attacks while requiring the actual CSRF token in a cookie does not work because cookies are automatically included in the HTTP request by the browser.

CSRF tokens can be obtained in various ways. For server-rendered applications, the token is typically embedded in the initial HTML response after authentication, while single-page applications may receive it during authentication or via a dedicated API call. In some cases, the token is dynamically generated per request or pre-fetched explicitly through a specific endpoint before state-changing operations.
### SameSite Attribute
A server can specify the `SameSite` attribute when setting a cookie to indicate that the cookie should not be sent when coming from external sites.
> Spring Security relies on Spring Session for SameSite.
* Strict:
    -   Cookies are only sent with requests originating from the same site as the one that set the cookie.
    -   Cross-site requests (e.g., links or forms from another site) will not include the cookie.
    -   Best for highly sensitive cookies but may impact usability.
* Lax (Default for modern browsers):
    -   Cookies are sent with top-level navigation (e.g., clicking a link) but not with embedded content (e.g., images or iframes).
    -   Balances security and usability, making it suitable for most cases.
* None:
    -   Cookies are sent with all requests, including cross-site requests.
    -   Requires the cookie to be marked as `Secure` (sent over HTTPS) to prevent potential security risks.
<!--stackedit_data:
eyJoaXN0b3J5IjpbNzQ4MDQzNTk0XX0=
-->