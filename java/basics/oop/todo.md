# Type Invariance
The essence is to provide an API that represents a given set and checks the input data. Type invariance is a **representation function** that occurs during the **creation** (constructor) or **setting** (setter) of an object. This function can be a **check** and/or even an **operation**. Depending on the input parameters, the object is created/retained or an error is thrown by the type invariant function.
# Inheritance
Single inheritance, parent to child. If `B extends A` and `C extends B`, then `C` is a descendant/child of `A`.
## Object
Every class implicitly inherits the following:
-   `hashCode`: A unique identifier generated by the **JVM**
-   `equals`
-   `getClass`
-   `toString`: String representation of the object
-   etc.
## Super
`super` keyword is used to refer to the immediate parent class object.
### Invoking constructor
It allows the initialization of the inherited members from the parent class.
```java
class Parent {
    int x;
    Parent(int x) { this.x = x; }
}

class Child extends Parent {
    int y;
    Child(int x, int y) { super(x); this.y = y; }
}
```
### Accessing fields or methods
When a subclass has a field or method with the same name as a field or method in its parent class.
```java
class Parent {
    int x = 10;
    void display() { System.out.println("Parent class"); }
}

class Child extends Parent {
    int x = 20;
    void display() {
        System.out.println("Child class " + x);
        super.display();
        System.out.println("Parent class" + super.x);
    }
}
```
# Liskov Substitution Principle
An `A` type is a subtype of `B` (base type), if we can use instances of `A` instead of instances of `B` without causing any problems.
## Upcasting
Implicit, due to the Liskov principle.
```java
ExactTime extends Time{...}
...
Exactime time1 = new ExactTime();
//upcast
Time time2 = new ExactTime();
```
## Downcast
Explicit, determined at runtime.
```java
Object o = new Time(...);
o.aMinutePassed(); //fordítási hiba, az Object statikusan nem tartalmaz ilyen mezőt
((Time)o).aMinutePassed(); //lefordul, működik
```
# Static and Dynamic Types
The compiler checks the static type, known at compile time. The dynamic type is revealed at runtime but is a subtype of the static type.
## Parametric Polymorphism
-   The same code works for multiple types.
-   Only works for reference types.
## Dynamic Binding
Since the static type is known at compile time, any subtype of it can be present at runtime.
```java
ExactTime e = new ExactTime();
Time t = e;
Object o = t;

System.out.println(e.toString()); //0:00:00
System.out.println(t.toString()); //0:00:00
System.out.println(o.toString()); //0:00:00
```
## Shadowing
What is not dynamically bound is shadowing.
```java
class Base{
	int value = 5;
	int fMethod(){ return value; }
	static int sMethod() { return 5; }
}

class Sub extends Base {
	int value = 15;
	static int sMethod() { return 15; }

...
base.value //5
base.fMethod() //5
base.sMethod() //5
sub.value //15
sub.fMethod() //5
sub.sMethod() //15
```
# Anonymous inner classes
Java anonymous inner class is an inner class without a name and for which only a single object is created.

It can be useful when making an instance of an object with certain "extras" such as overloading methods of a class or interface, without having to actually subclass a class.
They can be created in two ways
1.  Class (may be abstract or concrete)
2.  Interface
```java
class Anonymous{
	public void hello(){
		System.out.println("Hello!");
	}
}

class Main{
	public static void main(String args[]){
		Anonymous person = new Anonymous(){  
			void hello(){  
				System.out.println("Hello World!");  
			}  
		};  
  
		Runnable anonymRunnable = new Runnable() {  
			@Override  
			public void run() {  
				System.out.println();  
			}  
		};
	}
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTA5MDQwNDUzMV19
-->